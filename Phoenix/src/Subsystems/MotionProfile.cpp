// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "MotionProfile.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/RunMotionProfile.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

MotionProfile::MotionProfile() : frc::Subsystem("MotionProfile") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	frontleft = RobotMap::drivetrainfrontleft;
	frontright = RobotMap::drivetrainfrontright;


	_lpos = 0.0;
	_rpos = 0.0;

	_lvel=0.0;
	_rvel=0.0;

	_lheading=0.0;

	_rheading=0.0;

	_state = 0;

	_loopTimeout = -1;

	_bStart = false;



	_setValue = SetValueMotionProfile::Disable;



	//_notifier = new Notifier(Periodic());



}



void MotionProfile::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new RunMotionProfile());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


void MotionProfile::Periodic() {
    // Put code here to be run every loop


	frontleft->ProcessMotionProfileBuffer();
	frontright->ProcessMotionProfileBuffer();

	frontleft->ChangeMotionControlFramePeriod(25);
	frontright->ChangeMotionControlFramePeriod(25);


	//_notifier.StartPeriodic(0.025);


	SetValueMotionProfile setOutput = getSetValue();

	control();

	frontleft->Set(ControlMode::MotionProfile, setOutput);
	frontright->Set(ControlMode::MotionProfile, setOutput);

}


// Put methods for controlling this subsystem
// here. Call these from Commands.



void MotionProfile::initMotionProfile(){
	Robot::drivetrain->encoderReset();

	reset();

	frontleft->Set(ControlMode::MotionProfile, _setValue);
	frontright->Set(ControlMode::MotionProfile, _setValue);

	frontleft->ClearMotionProfileHasUnderrun(10);
	frontright->ClearMotionProfileHasUnderrun(10);


	frontleft->SelectProfileSlot(1,0);
	frontright->SelectProfileSlot(1,0);


	frontleft->ConfigMotionProfileTrajectoryPeriod(50, 10); //50 ms for our profile
	frontright->ConfigMotionProfileTrajectoryPeriod(50,10);

	frontleft->SetStatusFramePeriod(StatusFrameEnhanced::Status_10_MotionMagic, 50, 10);
	frontright->SetStatusFramePeriod(StatusFrameEnhanced::Status_10_MotionMagic,50, 10);




}

void MotionProfile::reset()
	{
		/*
		 * Let's clear the buffer just in case user decided to disable in the
		 * middle of an MP, and now we have the second half of a profile just
		 * sitting in memory.
		 */
	frontleft->ClearMotionProfileTrajectories();
	frontright->ClearMotionProfileTrajectories();
		/* When we do re-enter motionProfile control mode, stay disabled. */
		_setValue = SetValueMotionProfile::Disable;
		/* When we do start running our state machine start at the beginning. */
		_state = 0;
		_loopTimeout = -1;
		/*
		 * If application wanted to start an MP before, ignore and wait for next
		 * button press
		 */
		_bStart = false;
	}

void MotionProfile::control()
	{

		/*
		 * track time, this is rudimentary but that's okay, we just want to make
		 * sure things never get stuck.
		 */
		if (_loopTimeout < 0) {
			/* do nothing, timeout is disabled */
		} else {
			/* our timeout is nonzero */
			if (_loopTimeout == 0) {
				/*
				 * something is wrong. Talon is not present, unplugged, breaker
				 * tripped
				 */
				//Instrumentation::OnNoProgress();
			} else {
				--_loopTimeout;
			}
		}

		/* first check if we are in MP mode */
		if((frontleft->GetControlMode() != ControlMode::MotionProfile) || frontright->GetControlMode() != ControlMode::MotionProfile){
			/*
			 * we are not in MP mode. We are probably driving the robot around
			 * using gamepads or some other mode.
			 */
			_state = 0;
			_loopTimeout = -1;
		} else {
			/*
			 * we are in MP control mode. That means: starting Mps, checking Mp
			 * progress, and possibly interrupting MPs if thats what you want to
			 * do.
			 */
			switch (_state) {
				case 0: /* wait for application to tell us to start an MP */
					if (_bStart) {
						_bStart = false;

						_setValue = SetValueMotionProfile::Disable;
						startFilling();
						/*
						 * MP is being sent to CAN bus, wait a small amount of time
						 */
						_state = 1;
						_loopTimeout = kNumLoopsTimeout;
					}
					break;
				case 1: /*
						 * wait for MP to stream to Talon, really just the first few
						 * points
						 */
					/* do we have a minimum numberof points in Talon */
					if (_status.btmBufferCnt > kMinPointsInTalon) {
						/* start (once) the motion profile */
						_setValue = SetValueMotionProfile::Enable;
						/* MP will start once the control frame gets scheduled */
						_state = 2;
						_loopTimeout = kNumLoopsTimeout;
					}
					break;
				case 2: /* check the status of the MP */
					/*
					 * if talon is reporting things are good, keep adding to our
					 * timeout. Really this is so that you can unplug your talon in
					 * the middle of an MP and react to it.
					 */
					if (_status.isUnderrun == false) {
						_loopTimeout = kNumLoopsTimeout;
					}
					/*
					 * If we are executing an MP and the MP finished, start loading
					 * another. We will go into hold state so robot servo's
					 * position.
					 */
					if (_status.activePointValid && _status.isLast) {
						/*
						 * because we set the last point's isLast to true, we will
						 * get here when the MP is done
						 */
						_setValue = SetValueMotionProfile::Hold;
						_state = 0;
						_loopTimeout = -1;
					}
					break;
			}

			/* Get the motion profile status every loop */
			frontleft->GetMotionProfileStatus(_status);
			frontright->GetMotionProfileStatus(_status);

			_lheading = frontleft->GetActiveTrajectoryHeading();
			_rheading = frontright->GetActiveTrajectoryHeading();

			_lpos = frontleft->GetActiveTrajectoryPosition();
			_rpos = frontright->GetActiveTrajectoryPosition();

			_lvel = frontleft->GetActiveTrajectoryVelocity();
			_rvel = frontright->GetActiveTrajectoryVelocity();


		}
	}

TrajectoryDuration GetTrajectoryDuration(int durationMs)
	{
		/* lookup and return valid value */
		switch (durationMs) {
			case 0:		return TrajectoryDuration_0ms;
			case 5:		return TrajectoryDuration_5ms;
			case 10: 	return TrajectoryDuration_10ms;
			case 20: 	return TrajectoryDuration_20ms;
			case 30: 	return TrajectoryDuration_30ms;
			case 40: 	return TrajectoryDuration_40ms;
			case 50: 	return TrajectoryDuration_50ms;
			case 100: 	return TrajectoryDuration_100ms;
		}
		printf("Trajectory Duration not supported - use configMotionProfileTrajectoryPeriod instead\n");
		return TrajectoryDuration_100ms;
	}

/** Start filling the MPs to all of the involved Talons. */
	void MotionProfile::startFilling()
	{
		/* since this example only has one talon, just update that one */
		startFilling(kLeftMotionProfile, kLeftMotionProfileSz);
		startFilling(kRightMotionProfile, kRightMotionProfileSz);
	}

	void MotionProfile::startFilling(const double profile[][3], int totalCnt)
		{
			/* create an empty point */
			TrajectoryPoint point;

			/* did we get an underrun condition since last time we checked ? */
			if(_status.hasUnderrun){
				/* better log it so we know about it */
				//Instrumentation::OnUnderrun();
				/*
				 * clear the error. This is what seperates "has underrun" from
				 * "is underrun", because the former is cleared by the application.
				 * That way, we never miss logging it.
				 */
				frontleft->ClearMotionProfileHasUnderrun(10);
				frontright->ClearMotionProfileHasUnderrun(10);
			}

			/*
			 * just in case we are interrupting another MP and there is still buffer
			 * points in memory, clear it.
			 */
			frontleft->ClearMotionProfileTrajectories();
			frontright->ClearMotionProfileTrajectories();

			/* set the base trajectory period to zero, use the individual trajectory period below */
			frontleft->ConfigMotionProfileTrajectoryPeriod(0, 10);
			frontright->ConfigMotionProfileTrajectoryPeriod(0, 10);

			/* This is fast since it's just into our TOP buffer */
			for(int i=0;i<totalCnt;++i){
				double positionRot = profile[i][0];
				double velocityRPM = profile[i][1];

				/* for each point, fill our structure and pass it to API */
				point.position = positionRot * 80 ;  //Convert Revolutions to Units
				point.velocity = velocityRPM * 80 / 600.0; //Convert RPM to Units/100ms
				point.headingDeg = 0; /* future feature - not used in this example*/
				point.profileSlotSelect0 = 0; /* which set of gains would you like to use [0,3]? */
				point.profileSlotSelect1 = 0; /* future feature  - not used in this example - cascaded PID [0,1], leave zero */
				point.timeDur = GetTrajectoryDuration((int)profile[i][2]);
				point.zeroPos = false;
				if (i == 0)
					point.zeroPos = true; /* set this to true on the first point */

				point.isLastPoint = false;
				if ((i + 1) == totalCnt)
					point.isLastPoint = true; /* set this to true on the last point  */

				frontleft->PushMotionProfileTrajectory(point);
				frontright->PushMotionProfileTrajectory(point);
			}
		}

	void MotionProfile::start() {
			_bStart = true;
		}

		/**
		 *
		 * @return the output value to pass to Talon's set() routine. 0 for disable
		 *         motion-profile output, 1 for enable motion-profile, 2 for hold
		 *         current motion profile trajectory point.
		 */
	SetValueMotionProfile MotionProfile::getSetValue() {
			return _setValue;
		}


